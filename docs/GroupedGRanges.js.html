<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>GroupedGRanges.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/LTLA/bioconductor.js" target="_blank" class="menu-item" id="repository" >Code Repo</a></h2><h3>Classes</h3><ul><li><a href="Annotated.html">Annotated</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Annotated.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="Annotated.html#metadata">metadata</a></li></ul></li><li><a href="DataFrame.html">DataFrame</a><ul class='methods'><li data-type='method' style='display: none;'><a href="DataFrame.html#$removeColumn">$removeColumn</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$setColumn">$setColumn</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$setColumnNames">$setColumnNames</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$setRowNames">$setRowNames</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$sliceColumns">$sliceColumns</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#column">column</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#columnNames">columnNames</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#hasColumn">hasColumn</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#numberOfColumns">numberOfColumns</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#numberOfRows">numberOfRows</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#rowNames">rowNames</a></li></ul></li><li><a href="DenseMatrix.html">DenseMatrix</a><ul class='methods'><li data-type='method' style='display: none;'><a href="DenseMatrix.html#$setColumn">$setColumn</a></li><li data-type='method' style='display: none;'><a href="DenseMatrix.html#$setRow">$setRow</a></li><li data-type='method' style='display: none;'><a href="DenseMatrix.html#$setValues">$setValues</a></li><li data-type='method' style='display: none;'><a href="DenseMatrix.html#column">column</a></li><li data-type='method' style='display: none;'><a href="DenseMatrix.html#isColumnMajor">isColumnMajor</a></li><li data-type='method' style='display: none;'><a href="DenseMatrix.html#numberOfColumns">numberOfColumns</a></li><li data-type='method' style='display: none;'><a href="DenseMatrix.html#numberOfRows">numberOfRows</a></li><li data-type='method' style='display: none;'><a href="DenseMatrix.html#row">row</a></li><li data-type='method' style='display: none;'><a href="DenseMatrix.html#values">values</a></li></ul></li><li><a href="GRanges.html">GRanges</a><ul class='methods'><li data-type='method' style='display: none;'><a href="GRanges.html#.empty">empty</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setElementMetadata">$setElementMetadata</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setNames">$setNames</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setRanges">$setRanges</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setSeqnames">$setSeqnames</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setStart">$setStart</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setStrand">$setStrand</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setWidth">$setWidth</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#buildOverlapIndex">buildOverlapIndex</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#elementMetadata">elementMetadata</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#end">end</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#names">names</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#ranges">ranges</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#seqnames">seqnames</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#start">start</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#strand">strand</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#width">width</a></li></ul></li><li><a href="GRangesOverlapIndex.html">GRangesOverlapIndex</a><ul class='methods'><li data-type='method' style='display: none;'><a href="GRangesOverlapIndex.html#overlap">overlap</a></li></ul></li><li><a href="GroupedGRanges.html">GroupedGRanges</a><ul class='methods'><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#.empty">empty</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#$setElementMetadata">$setElementMetadata</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#$setGroup">$setGroup</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#$setNames">$setNames</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#$setRanges">$setRanges</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#buildOverlapIndex">buildOverlapIndex</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#elementMetadata">elementMetadata</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#group">group</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#names">names</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#numberOfGroups">numberOfGroups</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#rangeLengths">rangeLengths</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#ranges">ranges</a></li><li data-type='method' style='display: none;'><a href="GroupedGRanges.html#rangeStarts">rangeStarts</a></li></ul></li><li><a href="GroupedGRangesOverlapIndex.html">GroupedGRangesOverlapIndex</a><ul class='methods'><li data-type='method' style='display: none;'><a href="GroupedGRangesOverlapIndex.html#overlap">overlap</a></li></ul></li><li><a href="IRanges.html">IRanges</a><ul class='methods'><li data-type='method' style='display: none;'><a href="IRanges.html#.empty">empty</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#$setElementMetadata">$setElementMetadata</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#$setNames">$setNames</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#$setStart">$setStart</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#$setWidth">$setWidth</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#buildOverlapIndex">buildOverlapIndex</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#elementMetadata">elementMetadata</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#end">end</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#names">names</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#start">start</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#width">width</a></li></ul></li><li><a href="IRangesOverlapIndex.html">IRangesOverlapIndex</a><ul class='methods'><li data-type='method' style='display: none;'><a href="IRangesOverlapIndex.html#overlap">overlap</a></li></ul></li><li><a href="RangedSummarizedExperiment.html">RangedSummarizedExperiment</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#$removeAssay">$removeAssay</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#$setAssay">$setAssay</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#$setColumnData">$setColumnData</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#$setColumnNames">$setColumnNames</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#$setRowData">$setRowData</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#$setRowNames">$setRowNames</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#$setRowRanges">$setRowRanges</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#assay">assay</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#assayNames">assayNames</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#columnData">columnData</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#columnNames">columnNames</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#numberOfAssays">numberOfAssays</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#numberOfColumns">numberOfColumns</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#numberOfRows">numberOfRows</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#rowData">rowData</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#rowNames">rowNames</a></li><li data-type='method' style='display: none;'><a href="RangedSummarizedExperiment.html#rowRanges">rowRanges</a></li></ul></li><li><a href="SingleCellExperiment.html">SingleCellExperiment</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#$removeAlternativeExperiment">$removeAlternativeExperiment</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#$removeAssay">$removeAssay</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#$removeReducedDimension">$removeReducedDimension</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#$setAlternativeExperiment">$setAlternativeExperiment</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#$setAssay">$setAssay</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#$setColumnData">$setColumnData</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#$setColumnNames">$setColumnNames</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#$setReducedDimension">$setReducedDimension</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#$setRowData">$setRowData</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#$setRowNames">$setRowNames</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#$setRowRanges">$setRowRanges</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#alternativeExperiment">alternativeExperiment</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#alternativeExperimentNames">alternativeExperimentNames</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#assay">assay</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#assayNames">assayNames</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#columnData">columnData</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#columnNames">columnNames</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#numberOfAssays">numberOfAssays</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#numberOfColumns">numberOfColumns</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#numberOfRows">numberOfRows</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#reducedDimension">reducedDimension</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#reducedDimensionNames">reducedDimensionNames</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#rowData">rowData</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#rowNames">rowNames</a></li><li data-type='method' style='display: none;'><a href="SingleCellExperiment.html#rowRanges">rowRanges</a></li></ul></li><li><a href="SummarizedExperiment.html">SummarizedExperiment</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#$removeAssay">$removeAssay</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#$setAssay">$setAssay</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#$setColumnData">$setColumnData</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#$setColumnNames">$setColumnNames</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#$setRowData">$setRowData</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#$setRowNames">$setRowNames</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#assay">assay</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#assayNames">assayNames</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#columnData">columnData</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#columnNames">columnNames</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#numberOfAssays">numberOfAssays</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#numberOfColumns">numberOfColumns</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#numberOfRows">numberOfRows</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#rowData">rowData</a></li><li data-type='method' style='display: none;'><a href="SummarizedExperiment.html#rowNames">rowNames</a></li></ul></li><li><a href="Vector.html">Vector</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Vector.html#$setElementMetadata">$setElementMetadata</a></li><li data-type='method' style='display: none;'><a href="Vector.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="Vector.html#$setNames">$setNames</a></li><li data-type='method' style='display: none;'><a href="Vector.html#elementMetadata">elementMetadata</a></li><li data-type='method' style='display: none;'><a href="Vector.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="Vector.html#names">names</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#CLONE">CLONE</a></li><li><a href="global.html#COMBINE">COMBINE</a></li><li><a href="global.html#COMBINE_COLUMNS">COMBINE_COLUMNS</a></li><li><a href="global.html#COMBINE_ROWS">COMBINE_ROWS</a></li><li><a href="global.html#flexibleCombineRows">flexibleCombineRows</a></li><li><a href="global.html#LENGTH">LENGTH</a></li><li><a href="global.html#NUMBER_OF_COLUMNS">NUMBER_OF_COLUMNS</a></li><li><a href="global.html#NUMBER_OF_ROWS">NUMBER_OF_ROWS</a></li><li><a href="global.html#presplitFactor">presplitFactor</a></li><li><a href="global.html#SLICE">SLICE</a></li><li><a href="global.html#SLICE_2D">SLICE_2D</a></li><li><a href="global.html#SPLIT">SPLIT</a></li><li><a href="global.html#which">which</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">GroupedGRanges.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as vec from "./Vector.js";
import * as gr from "./GRanges.js";
import * as utils from "./utils.js";
import * as generics from "./AllGenerics.js";

/**
 * A GroupedGRanges object is a collection of groups of genomic ranges, inspired by the `GRangesList` class from the Bioconductor ecosystem.
 * Each group consists of a {@linkplain GRanges} object of arbitrary length, which is most often used to represent a multi-exon gene.
 * The GroupedGRanges can be considered a vector of groups, and defines methods for the following generics:
 *
 * - {@linkcode LENGTH}
 * - {@linkcode SLICE}
 * - {@linkcode COMBINE}
 * - {@linkcode CLONE}
 *
 * Our implementation re-uses Bioconductor's strategy of storing the groups in a single concatenated GRanges.
 * This improves efficiency for large numbers of small GRanges, especially in placeholder objects where all the GRanges are zero-length.
 * 
 * @extends Vector
 */
export class GroupedGRanges extends vec.Vector {
    static #computeStarts(lengths) {
        let starts = new Int32Array(lengths.length);
        let last = 0;
        for (var i = 0; i &lt; lengths.length; i++) {
            starts[i] = last;
            last += lengths[i];
        }
        return { starts: starts, total: last };
    }

    _staged_set_groups;

    /**
     * @param {Array|GRanges} ranges - An array of {@linkplain GRanges} objects, where each element represents a group of genomic ranges.
     * All objects should have compatible columns in their {@linkplain Vector#elementMetadata elementMetadata}.
     * 
     * Alternatively, a single GRanges containing a concatenation of ranges from all groups.
     * In this case, `rangeLengths` must be supplied.
     * @param {Object} [options={}] - Optional parameters.
     * @param {?(TypedArray|Array)} [options.rangeLengths=null] - Length of the ranges within each group.
     * This should be coercible to an Int32Array, contain non-negative values, and have a sum equal to the length of `ranges`.
     * Only used if `ranges` is a single {@linkplain GRanges} object, where each group's ranges are assumed to form contiguous intervals along `ranges`.
     * @param {?Array} [options.names=null] - Array of strings of length equal to `start`, containing names for each genomic range.
     * Alternatively `null`, in which case the ranges are assumed to be unnamed.
     * @param {?DataFrame} [options.elementMetadata=null] - A {@linkplain DataFrame} with number of rows equal to the length of `start`, containing arbitrary per-range annotations.
     * Alternatively `null`, in which case a zero-column DataFrame is automatically constructed.
     * @param {Object} [options.metadata={}] - Object containing arbitrary metadata as key-value pairs.
     */
    constructor(ranges, { rangeLengths = null, names = null, elementMetadata = null, metadata = {} } = {}) {
        if (ranges.constructor == Array) {
            super(ranges.length, { names, elementMetadata, metadata });
            rangeLengths = new Int32Array(ranges.length);
            for (var i = 0; i &lt; rangeLengths.length; i++) {
                if (!(ranges[i] instanceof gr.GRanges)) {
                    throw new Error("'ranges' must either be a 'GRanges' or an array of 'GRanges'");
                }
                rangeLengths[i] = generics.LENGTH(ranges[i]);
            }
            ranges = generics.COMBINE(ranges);

        } else {
            if (!(ranges instanceof gr.GRanges)) {
                throw new Error("'ranges' must either be a 'GRanges' or an array of 'GRanges'");
            }
            if (rangeLengths == null) {
                throw new Error("'rangeLengths' must be specified when 'ranges' is a 'GRanges'");
            }
            super(rangeLengths.length, { names, elementMetadata, metadata });
            rangeLengths = utils.convertToInt32Array(rangeLengths);
            utils.checkNonNegative(rangeLengths);
        }

        this._ranges = ranges;
        this._rangeLengths = rangeLengths;

        let accumulated = GroupedGRanges.#computeStarts(rangeLengths);
        this._rangeStarts = accumulated.starts;

        if (accumulated.total !== generics.LENGTH(ranges)) {
            throw new Error("sum of 'rangeLengths' must be equal to the length of 'ranges'");
        }

        this._staged_setGroup = null;
    }

    /**************************************************************************
     **************************************************************************
     **************************************************************************/

    /**
     * @return {GRanges} The concatenated set of ranges across all groups. 
     */
    ranges() {
        this._flush_staged_setGroup();
        return this._ranges;
    }

    /**
     * @return {Int32Array} The start indices for each group's ranges along the concatenated set of ranges returned by {@linkcode GroupedGRanges#ranges ranges}.
     */
    rangeStarts() {
        this._flush_staged_setGroup();
        return this._rangeStarts;
    }

    /**
     * @return {Int32Array} The length of each group's ranges along the concatenated set of ranges returned by {@linkcode GroupedGRanges#ranges ranges}.
     */
    rangeLengths() {
        this._flush_staged_setGroup();
        return this._rangeLengths;
    }

    /**
     * @param {number} i - Index of the group of interest.
     * @param {Object} [options={}] - Optional parameters.
     * @param {boolean} [options.allowView=false] - Whether a view can be created in any internal slicing operations.
     *
     * @return {GRanges} The genomic ranges for group `i`.
     */
    group(i, { allowView = false } = {}) {
        this._flush_staged_setGroup();
        let s = this._rangeStarts[i];
        return generics.SLICE(this._ranges, { start: s, end: s + this._rangeLengths[i] }, { allowView });
    }

    /**
     * @return {number} Number of groups in this object.
     */
    numberOfGroups() {
        return this._rangeStarts.length;
    }

    /**************************************************************************
     **************************************************************************
     **************************************************************************/

    /**
     * @param {GRanges} ranges - Genomic ranges of length equal to the concatenated set of ranges returned by {@linkcode GroupedGRanges#ranges ranges}.
     * @return {GroupedGRanges} A reference to this GroupedGRanges object after modifying the internal ranges.
     */
    $setRanges(ranges) {
        this._flush_staged_setGroup();
        if (!(ranges instanceof gr.GRanges)) {
            throw new Error("'ranges' must be a 'GRanges'");
        }
        if (generics.LENGTH(ranges) !== generics.LENGTH(this._ranges)) {
            throw utils.formatLengthError("'ranges'", "number of ranges");
        }
        this._ranges = ranges;
        return this;
    }

    _flush_staged_setGroup() {
        let staged = this._staged_setGroup;
        if (staged === null) {
            return;
        }
        staged.sort((a, b) => {
            let diff = a[0] - b[0];
            return (diff === 0 ? a[1] - b[1] : diff);
        });

        let counter = 0;
        let accumulated = 0;
        let last_start = 0;
        let more_ranges = [];

        let ngroups = this.numberOfGroups();
        for (var g = 0; g &lt; ngroups; g++) {
            if (counter &lt; staged.length &amp;&amp; g == staged[counter][0]) { 
                let current_start = this._rangeStarts[g];
                if (last_start &lt; current_start) {
                    more_ranges.push(generics.SLICE(this._ranges, { start: last_start, end: current_start }));
                }
                last_start = current_start + this._rangeLengths[g];

                let replacement;
                do {
                    replacement = staged[counter][2];
                    counter++;
                } while (counter &lt; staged.length &amp;&amp; g == staged[counter][0]);

                more_ranges.push(replacement);
                this._rangeLengths[g] = generics.LENGTH(replacement);
            }

            this._rangeStarts[g] = accumulated;
            accumulated += this._rangeLengths[g];
        }

        let nranges = generics.LENGTH(this._ranges);
        if (last_start &lt; nranges) {
            more_ranges.push(generics.SLICE(this._ranges, { start: last_start, end: nranges }));
        }

        try {
            this._ranges = generics.COMBINE(more_ranges);
        } catch (e) {
            throw new Error("failed to combine staged '$setGroup' operations; " + e.message);
        }
        return;
    }

    /**
     * Multiple consecutive calls to `$setGroup` are not executed immediately.
     * Rather, the operations are staged and executed in batch once the modified GroupedGRanges is used in other methods.
     * This enables efficient setting of individual groups inside a single concatenated {@linkplain GRanges}. 
     *
     * @param {number} i - Index of the group of interest.
     * @param {GRanges} ranges - Genomic ranges for group `i`.
     * @return {GroupedGRanges} A reference to this GroupedGRanges object after setting group `i`.
     */
    $setGroup(i, ranges) {
       if (this._staged_setGroup === null) {
            this._staged_setGroup = [];
        }
        let nops = this._staged_setGroup.length;
        this._staged_setGroup.push([i, nops, ranges]);
        return this;
    }

    /**************************************************************************
     **************************************************************************
     **************************************************************************/

    /**
     * @param {Object} [options={}] - Optional parameters.
     * @param {?(Array|Set)} [options.restrictToSeqnames=null] - Array or Set containing the sequence names to use in the index.
     * If `null`, all available sequence names are used.
     * @param {?(Array|Set)} [options.restrictToStrand=null] - Array or Set containing the strands to use in the index.
     * If `null`, all available strands are used.
     *
     * @return {GroupedGRangesOverlapIndex} A pre-built index for computing overlaps with other {@linkplain GRanges} instances.
     */
    buildOverlapIndex({ restrictToSeqnames = null, restrictToStrand = null } = {}) {
        this._flush_staged_setGroup();
        return new GroupedGRangesOverlapIndex(
            this._ranges.buildOverlapIndex({ restrictToSeqnames, restrictToStrand }),
            generics.LENGTH(this._ranges),
            this._rangeStarts,
            this._rangeLengths
        );
    }

    /**************************************************************************
     **************************************************************************
     **************************************************************************/

    _bioconductor_LENGTH() {
        return this._rangeStarts.length;
    }

    _bioconductor_SLICE(output, i, { allowView = false } = {}) {
        super._bioconductor_SLICE(output, i, { allowView });
        this._flush_staged_setGroup();

        output._rangeLengths = generics.SLICE(this._rangeLengths, i, { allowView });
        let accumulated = GroupedGRanges.#computeStarts(output._rangeLengths);
        output._rangeStarts = accumulated.starts;

        if (i.constructor == Object) {
            // Handle this specially for optimizing allowView = true.
            let s = this._rangeStarts[i.start];
            output._ranges = generics.SLICE(this._ranges, { start: s, end: s + accumulated.total }, { allowView });
        } else {
            let keep = new Int32Array(accumulated.total);

            let counter = 0;
            for (const j of i) {
                let start = this._rangeStarts[j];
                let end = start + this._rangeLengths[j];
                for (var k = start; k &lt; end; k++) {
                    keep[counter] = k;
                    counter++;
                }
            }

            output._ranges = generics.SLICE(this._ranges, keep, { allowView });
        }

        output._staged_setGroup = null;
        return;
    }

    _bioconductor_COMBINE(output, objects) {
        super._bioconductor_COMBINE(output, objects);

        // We need to flush the staged operations in each object.
        for (const o of objects) {
            o._flush_staged_setGroup();
        }

        output._rangeLengths = generics.COMBINE(objects.map(x => x._rangeLengths));
        let accumulated = GroupedGRanges.#computeStarts(output._rangeLengths);
        output._rangeStarts = accumulated.starts;
        output._ranges = generics.COMBINE(objects.map(x => x._ranges));

        output._staged_setGroup = null;
        return;
    }

    _bioconductor_CLONE(output, { deepCopy = true }) {
        super._bioconductor_CLONE(output, { deepCopy });
        this._flush_staged_setGroup();

        output._rangeLengths = generics.CLONE(this._rangeLengths, { deepCopy });
        output._rangeStarts = generics.CLONE(this._rangeStarts, { deepCopy });
        output._ranges = generics.CLONE(this._ranges, { deepCopy });

        output._staged_setGroup = null;
        return;
    }

    /**************************************************************************
     **************************************************************************
     **************************************************************************/

    /**
     * @param {number} [numberOfGroups=0] - Numbe of empty groups to create.
     * @return {GroupedGRanges} A GroupedGRanges object of length equal to `numberOfGroups`,
     * where each group is of zero length.
     */
    static empty(numberOfGroups) {
        let runs = new Int32Array(numberOfGroups);
        runs.fill(0);
        return new GroupedGRanges(gr.GRanges.empty(), { rangeLengths: runs });
    }
}

/**
 * Pre-built index for overlapping {@linkplain GroupedGRanges} objects.
 * This is typically constructed using the {@linkcode GroupedGRanges#buildOverlapIndex GroupedGRanges.buildOverlapIndex} method for a "reference" object,
 * and can be applied to different query GroupedGRanges or {@linkplain GRanges} to identify overlaps with the reference.
 *
 * @hideconstructor
 */
export class GroupedGRangesOverlapIndex {
    constructor(index, fullLength, rangeStarts, rangeLengths) {
        this._index = index;
        this._rangeStarts = rangeStarts;
        this._rangeLengths = rangeLengths;

        let rev_map = new Int32Array(fullLength);
        for (var i = 0; i &lt; rangeStarts.length; i++) {
            let start = rangeStarts[i];
            let end = start + rangeLengths[i];
            for (var s = start; s &lt; end; s++) {
                rev_map[s] = i;
            }
        }
        this._reverseMapping = rev_map;
    }

    /**
     * @param {GroupedGRanges|GRanges} query - The query object, containing ranges to be overlapped with those in the reference GroupedGRanges (that was used to construct this GroupedGRangesOverlapIndex object).
     * @param {Object} [options={}] - Optional parameters.
     * @param {boolean} [options.ignoreStrand=true] - Whether to ignore differences in strandedness between the ranges in `query` and the reference object.
     *
     * @return {Array} An array of length equal to the number of ranges or groups in `query`,
     * where each element is an array containing the indices of the overlapping ranges in the reference {@linkplain GRanges} object.
     */
    overlap(query, { ignoreStrand = true } = {}) {
        let output = new Array(this._rangeStarts.length);
        let rev_map = this._reverseMapping;

        if (query instanceof GroupedGRanges) {
            let overlaps = this._index.overlap(query._ranges);
            for (var i = 0; i &lt; query._rangeStarts.length; i++) {
                let start = query._rangeStarts[i];
                let end = start + query._rangeLengths[i];

                let results = new Set;
                for (var s = start; s &lt; end; s++) {
                    overlaps[s].forEach(x => results.add(rev_map[x]));
                }
                output[i] = Array.from(results);
            }

        } else {
            let overlaps = this._index.overlap(query);
            for (var i = 0; i &lt; overlaps.length; i++) {
                let results = new Set;
                overlaps[i].forEach(x => results.add(rev_map[x]));
                output[i] = Array.from(results);
            }
        }

        return output;
    }

}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Mon Jan 30 2023 17:54:55 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
