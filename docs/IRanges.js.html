<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>IRanges.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/LTLA/bioconductor.js" target="_blank" class="menu-item" id="repository" >Code Repo</a></h2><h3>Classes</h3><ul><li><a href="DataFrame.html">DataFrame</a><ul class='methods'><li data-type='method' style='display: none;'><a href="DataFrame.html#$removeColumn">$removeColumn</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$setColumn">$setColumn</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$setColumnNames">$setColumnNames</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$setRowNames">$setRowNames</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$sliceColumns">$sliceColumns</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#column">column</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#columnNames">columnNames</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#hasColumn">hasColumn</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#numberOfColumns">numberOfColumns</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#numberOfRows">numberOfRows</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#rowNames">rowNames</a></li></ul></li><li><a href="IRanges.html">IRanges</a><ul class='methods'><li data-type='method' style='display: none;'><a href="IRanges.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#$setNames">$setNames</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#$setRangeMetadata">$setRangeMetadata</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#$setStart">$setStart</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#$setWidth">$setWidth</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#end">end</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#names">names</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#rangeMetadata">rangeMetadata</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#start">start</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#width">width</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#CLONE">CLONE</a></li><li><a href="global.html#COMBINE">COMBINE</a></li><li><a href="global.html#flexibleCombineRows">flexibleCombineRows</a></li><li><a href="global.html#LENGTH">LENGTH</a></li><li><a href="global.html#presplitFactor">presplitFactor</a></li><li><a href="global.html#SLICE">SLICE</a></li><li><a href="global.html#SPLIT">SPLIT</a></li><li><a href="global.html#which">which</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">IRanges.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as generics from "./AllGenerics.js";
import * as utils from "./utils.js";
import * as df from "./DataFrame.js";

export function verifyRangeMetadata(rangeMetadata, numExpected, failMessage) {
    if (rangeMetadata !== null) {
        if (!(rangeMetadata instanceof df.DataFrame)) {
            throw new Error("'rangeMetadata' should be a DataFrame");
        }
        if (generics.LENGTH(rangeMetadata) !== numExpected) {
            throw new Error("'rangeMetadata' should have the same number of rows as '" + failMessage + "'");
        }
    } else {
        rangeMetadata = new df.DataFrame({}, { numberOfRows: numExpected });
    }
    return rangeMetadata;
}

/**
 * An IRanges object is a collection of integer ranges, inspired by the class of the same name from the Bioconductor ecosystem.
 * Each range consists of a start position and a width, and may be associated with arbitrary range-level metadata in a {@linkplain DataFrame}.
 * The IRanges defines methods for the following generics:
 *
 * - {@linkcode LENGTH}
 * - {@linkcode SLICE}
 * - {@linkcode COMBINE}
 * - {@linkcode CLONE}
 */
export class IRanges {
    static #convertToInt32Array(x) {
        if (x instanceof Int32Array) {
            return x;
        } else {
            return new Int32Array(x);
        }
    }

    static #checkNonNegative(x, msg) {
        for (const y of x) {
            if (y &lt; 0) {
                throw new Error("detected a negative entry in '" + msg + "'");
            }
        }
    }

    /**************************************************************************
     **************************************************************************
     **************************************************************************/

    /**
     * @param {Array|TypedArray} start - Array of start positions for each range.
     * This should be coercible into an Int32Array.
     * @param {Array|TypedArray} width - Array of widths for each range.
     * This should be coercible into an Int32Array.
     * @param {Object} [options={}] - Optional parameters.
     * @param {?Array} [options.names=null] - Array of strings of length equal to `start`, containing names for each range.
     * Alternatively `null`, in which case the ranges are assumed to be unnamed.
     * @param {?DataFrame} [options.rangeMetadata=null] - A {@linkplain DataFrame} with number of rows equal to the length of `start`, containing arbitrary per-range annotations.
     * Alternatively `null`, in which case a zero-column DataFrame is automatically constructed.
     * @param {Object} [options.metadata={}] - Object containing arbitrary metadata as key-value pairs.
     */
    constructor(start, width, { names = null, rangeMetadata = null, metadata = {} } = {}) {
        this._start = IRanges.#convertToInt32Array(start);
        IRanges.#checkNonNegative(this._start, "start");

        this._width = IRanges.#convertToInt32Array(width);
        IRanges.#checkNonNegative(this._width, "width");

        let n = this._start.length;
        if (n !== this._width.length) {
            throw new Error("'start' and 'width' should have the same length");
        }

        this._rangeMetadata = verifyRangeMetadata(rangeMetadata, n, "start.length");

        if (names !== null) {
            utils.checkNamesArray(names, "'names'", n, "'start.length'");
        }
        this._names = names;

        this._metadata = metadata;
    }

    /**************************************************************************
     **************************************************************************
     **************************************************************************/

    /**
     * @return {Int32Array} Array of integers containing the start position for each range.
     */
    start() {
        return this._start;
    }

    /**
     * @return {Int32Array} Array of integers containing the end position (specifically, one-past-the-end) for each range.
     */
    end() {
        return this._start.map((x, i) => x + this._width[i]);
    }

    /**
     * @return {Int32Array} Array of integers containing the width of each range.
     */
    width() {
        return this._width;
    }

    /**
     * @return {?Array} Array of strings containing the name of each range, or `null` if no names are available.
     */
    names() {
        return this._names;
    }

    /**
     * @return {DataFrame} A {@linkplain DataFrame} with one row corresponding to each range, containing arbitrary per-range metadata.
     */
    rangeMetadata() {
        return this._rangeMetadata;
    }

    /**
     * @return {Object} Object containing arbitrary metadata.
     */
    metadata() {
        return this._metadata;
    }

    /**************************************************************************
     **************************************************************************
     **************************************************************************/

    /**
     * @param {Array|TypedArray} value - Array of start positions for each range.
     * This should have length equal to the number of ranges and be coercible into an Int32Array.
     * @return {IRanges} A reference to this IRanges object, after setting the start positions to `value`.
     */
    $setStart(value) {
        let candidate = IRanges.#convertToInt32Array(value);
        if (candidate.length !== generics.LENGTH(this)) {
            throw new Error("'start' should be replaced by array of the same length");
        }
        IRanges.#checkNonNegative(candidate, "start");
        this._start = candidate;
        return this;
    }

    /**
     * @param {Array|TypedArray} value - Array of widths for each range.
     * This should have length equal to the number of ranges and be coercible into an Int32Array.
     * @return {IRanges} A reference to this IRanges object, after setting the widths to `value`.
     */
    $setWidth(value) {
        let candidate = IRanges.#convertToInt32Array(value);
        if (candidate.length !== generics.LENGTH(this)) {
            throw new Error("'width' should be replaced by array of the same length");
        }
        IRanges.#checkNonNegative(candidate, "width");
        this._width = candidate;
        return this;
    }

    /**
     * @param {?Array} names - Array of strings containing a name for each range.
     * This should have length equal to the number of ranges.
     * Alternatively `null`, if no names are present.
     * @return {IRanges} A reference to this IRanges object, after setting the names to `value`.
     */
    $setNames(names) {
        if (names !== null) {
            utils.checkNamesArray(names, "replacement 'names'", generics.LENGTH(this), "'LENGTH(&lt;IRanges>)'");
        } 
        this._names = names;
        return this;
    }

    /**
     * @param {?DataFrame} value - Arbitrary metadata for each range.
     * This should have number of rows equal to the number of ranges.
     * Alternatively `null`, in which case all existing per-range metadata is removed.
     * @return {IRanges} A reference to this IRanges object, after setting the widths to `value`.
     */
    $setRangeMetadata(value) {
        this._rangeMetadata = verifyRangeMetadata(value, generics.LENGTH(this), "LENGTH(&lt;IRanges>)");
        return this;
    }

    /**
     * @param {Object} value - Object containing the metadata.
     *
     * @return {IRanges} Reference to this DataFrame after replacing the metadata.
     */
    $setMetadata(value) {
        this._metadata = value;
        return this;
    }

    /**************************************************************************
     **************************************************************************
     **************************************************************************/

    _bioconductor_LENGTH() {
        return this._start.length;
    }

    _bioconductor_SLICE(i, { allowInPlace = false, allowView = false }) {
        let options = { allowInPlace, allowView };
        let s = generics.SLICE(this._start, i, options);
        let w = generics.SLICE(this._width, i, options);
        let r = generics.SLICE(this._rangeMetadata, i, options);
        let n = (this._names == null ? null : generics.SLICE(this._names, i, options));

        if (allowInPlace) {
            this._start = s;
            this._width = w;
            this._rangeMetadata = r;
            this._names = n;
            return this;
        } else {
            let output = Object.create(this.constructor.prototype); // avoid validity checks.
            output._start = s;
            output._width = w;
            output._rangeMetadata = r;
            output._names = n;
            output._metadata = this._metadata;
            return output;
        }
    }

    _bioconductor_COMBINE(objects, { allowAppend = false }) {
        let all_s = [];
        let all_w = [];
        let all_r = [];
        let all_n = [];
        let all_l = [];

        for (const x of objects) {
            all_s.push(x._start);
            all_w.push(x._width);
            all_r.push(x._rangeMetadata);
            all_n.push(x._names);
            all_l.push(generics.LENGTH(x));
        }

        let combined_s = generics.COMBINE(all_s);
        let combined_w = generics.COMBINE(all_w);
        let combined_r = generics.COMBINE(all_r);
        let combined_n = utils.combineNames(all_n, all_l);

        if (allowAppend) {
            this._start = combined_s;
            this._width = combined_w;
            this._rangeMetadata = combined_r;
            this._names = combined_n;
            return this;
        } else {
            let output = Object.create(this.constructor.prototype); // avoid validity checks.
            output._start = combined_s;
            output._width = combined_w;
            output._rangeMetadata = combined_r;
            output._names = combined_n;
            output._metadata = this._metadata;
            return output;
        }
    }

    _bioconductor_CLONE({ deepcopy = true }) {
        let options = { deepcopy };
        let output = Object.create(this.constructor.prototype); // avoid validity checks.
        output._start = generics.CLONE(this._start, options);
        output._width = generics.CLONE(this._width, options);
        output._rangeMetadata = generics.CLONE(this._rangeMetadata, options);
        output._names = (this._names == null ? null : generics.CLONE(this._names, options));
        output._metadata = generics.CLONE(this._metadata, options);
        return output;
    }
}

</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Sun Jan 15 2023 08:25:14 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
