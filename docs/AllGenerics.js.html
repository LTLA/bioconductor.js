<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>AllGenerics.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/LTLA/bioconductor.js" target="_blank" class="menu-item" id="repository" >Code Repo</a></h2><h3>Classes</h3><ul><li><a href="Annotated.html">Annotated</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Annotated.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="Annotated.html#metadata">metadata</a></li></ul></li><li><a href="DataFrame.html">DataFrame</a><ul class='methods'><li data-type='method' style='display: none;'><a href="DataFrame.html#$removeColumn">$removeColumn</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$setColumn">$setColumn</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$setColumnNames">$setColumnNames</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$setRowNames">$setRowNames</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#$sliceColumns">$sliceColumns</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#column">column</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#columnNames">columnNames</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#hasColumn">hasColumn</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#numberOfColumns">numberOfColumns</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#numberOfRows">numberOfRows</a></li><li data-type='method' style='display: none;'><a href="DataFrame.html#rowNames">rowNames</a></li></ul></li><li><a href="GRanges.html">GRanges</a><ul class='methods'><li data-type='method' style='display: none;'><a href="GRanges.html#$setElementMetadata">$setElementMetadata</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setNames">$setNames</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setRanges">$setRanges</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setSeqnames">$setSeqnames</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setStart">$setStart</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setStrand">$setStrand</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#$setWidth">$setWidth</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#buildOverlapIndex">buildOverlapIndex</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#elementMetadata">elementMetadata</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#end">end</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#names">names</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#ranges">ranges</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#seqnames">seqnames</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#start">start</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#strand">strand</a></li><li data-type='method' style='display: none;'><a href="GRanges.html#width">width</a></li></ul></li><li><a href="GRangesOverlapIndex.html">GRangesOverlapIndex</a><ul class='methods'><li data-type='method' style='display: none;'><a href="GRangesOverlapIndex.html#overlap">overlap</a></li></ul></li><li><a href="IRanges.html">IRanges</a><ul class='methods'><li data-type='method' style='display: none;'><a href="IRanges.html#$setElementMetadata">$setElementMetadata</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#$setNames">$setNames</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#$setStart">$setStart</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#$setWidth">$setWidth</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#buildOverlapIndex">buildOverlapIndex</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#elementMetadata">elementMetadata</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#end">end</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#names">names</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#start">start</a></li><li data-type='method' style='display: none;'><a href="IRanges.html#width">width</a></li></ul></li><li><a href="IRangesOverlapIndex.html">IRangesOverlapIndex</a><ul class='methods'><li data-type='method' style='display: none;'><a href="IRangesOverlapIndex.html#overlap">overlap</a></li></ul></li><li><a href="Vector.html">Vector</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Vector.html#$setElementMetadata">$setElementMetadata</a></li><li data-type='method' style='display: none;'><a href="Vector.html#$setMetadata">$setMetadata</a></li><li data-type='method' style='display: none;'><a href="Vector.html#$setNames">$setNames</a></li><li data-type='method' style='display: none;'><a href="Vector.html#elementMetadata">elementMetadata</a></li><li data-type='method' style='display: none;'><a href="Vector.html#metadata">metadata</a></li><li data-type='method' style='display: none;'><a href="Vector.html#names">names</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#CLONE">CLONE</a></li><li><a href="global.html#COMBINE">COMBINE</a></li><li><a href="global.html#flexibleCombineRows">flexibleCombineRows</a></li><li><a href="global.html#LENGTH">LENGTH</a></li><li><a href="global.html#presplitFactor">presplitFactor</a></li><li><a href="global.html#SLICE">SLICE</a></li><li><a href="global.html#SPLIT">SPLIT</a></li><li><a href="global.html#which">which</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">AllGenerics.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as utils from "./utils.js";
import * as misc from "./miscellaneous.js";

/**
 * Compute the length of a vector-like object.
 *
 * For Array and TypedArrays, this just returns the `length` property directly.
 *
 * Custom classes should provide a `_bioconductor_LENGTH` method to describe their length.
 * This method should accept no arguments. 
 *
 * @param {*} x - Some vector-like object.
 * @return {number} Length of the object.
 */
export function LENGTH(x) {
    if ("_bioconductor_LENGTH" in x) {
        return x._bioconductor_LENGTH();
    }

    if (!utils.isArrayLike(x)) {
        throw new Error("no method for 'LENGTH' in '" + x.constructor.name + "' instance");
    }

    return x.length;
}

/**
 * Slice a vector-like object.
 *
 * For Array and TypedArrays, this just uses `slice()` or `subarray()`.
 *
 * Custom classes should provide a `_bioconductor_SLICE` method to create a slice.
 * This method should accept the same arguments as `SLICE` except for `x`.
 *
 * @param {*} x - Some vector-like object.
 * @param {Object|Array|TypedArray} i - An Array or TypedArray of integer indices specifying the slice of `x` to retain.
 *
 * Alternatively, an object containing `start` and `end`, where the slice is defined as the sequence of consecutive integers in `[start, end)`.
 * @param {Object} [options={}] - Optional parameters.
 * @param {boolean} [options.allowView=false] - Whether a view can be created to mimic the slice operation.
 * Whether this is actually done depends on the method, but may improve efficiency by avoiding unnecessary copies.
 *
 * @return {*} A vector-like object, typically of the same class as `x`, containing data for the specified slice.
 *
 * If `allowInPlace = true`, `x` _may_ be modified in place, and the return value _may_ be a reference to `x`. 
 */
export function SLICE(x, i, { allowView = false } = {}) {
    if ("_bioconductor_SLICE" in x) {
        let output = Object.create(x.constructor.prototype);
        x._bioconductor_SLICE(output, i, { allowView });
        return output;
    }

    if (!utils.isArrayLike(x)) {
        throw new Error("no method for 'SLICE' in '" + x.constructor.name + "' instance");
    }

    if (i.constructor == Object) {
        if (allowView &amp;&amp; ArrayBuffer.isView(x)) {
            return x.subarray(i.start, i.end);
        } else {
            return x.slice(i.start, i.end);
        }
    } else {
        let output = new x.constructor(i.length);
        i.forEach((y, j) => {
            output[j] = x[y];
        });
        return output;
    }
}

/**
 * Combine multiple vector-like objects.
 *
 * For Array and TypedArrays, the combined array is of a class that avoids information loss.
 *
 * Custom classes should provide a `_bioconductor_COMBINE` method to define the combining operation.
 * This method should accept the same arguments as `COMBINE`.
 *
 * @param {Array} objects - Array of vector-like objects to be combined.
 * It is assumed that the objects are of the same class, or at least compatible with each other -
 * for custom classes, the definition of "compatibility" depends on the `_bioconductor_COMBINE` method of the first element of `objects`.
 *
 * @return {*} A vector-like object containing the concatenated data from the input objects.
 * - If the first entry of `objects` is an instance of a custom class, the return value should be of the same class.
 * - If all `objects` are TypedArrays of the same class, the return value will be a TypedArray of that class.
 * - If any of the `objects` are Arrays, the return value will be an Array.
 * - If any of the `objects` are 64-bit TypedArrays of different classes, the return value will be an Array.
 * - Otherwise, for any other classes of TypedArrays in `objects`, the return value will be a Float64Array.
 */
export function COMBINE(objects) {
    let x = objects[0];
    if ("_bioconductor_COMBINE" in x) {
        let output = Object.create(x.constructor.prototype);
        x._bioconductor_COMBINE(output, objects);
        return output;
    }

    if (!utils.isArrayLike(x)) {
        throw new Error("no method for 'COMBINE' in '" + x.constructor.name + "' instance");
    }

    // It is assumed that every 'y' is of some compatible Array-like type as well.
    let total_LENGTH = 0;
    let constructor = x.constructor;

    for (const obj of objects) {
        total_LENGTH += obj.length;
        constructor = utils.chooseArrayConstructors(constructor, obj.constructor);
    }

    let output = new constructor(total_LENGTH);
    let position = 0;
    for (const obj of objects) {
        if ("set" in output) {
            output.set(obj, position);
            position += obj.length;
        } else {
            obj.forEach(x => {
                output[position] = x;
                position++;
            });
        }
    }

    return output;
}

/**
 * Clone a vector-like object.
 * 
 * For TypedArrays, this just uses `slice()`.
 * For Arrays, this creates a copy and runs `CLONE` on each element in the copy.
 *
 * Custom classes should provide a `_bioconductor_CLONE` method to define the cloning operation.
 * This method should accept the same arguments as `COMBINE` except for `x`.
 *
 * @param {*} x - Some vector-like object.
 * @param {Object} [options={}] - Optional parameters.
 * @param {boolean} [options.deepCopy=true] - Whether to create a deep copy.
 * The exact interpretation of `deepCopy=false` is left to each method, but generally speaking, 
 * any setter (`$`-marked) functions operating on the copy should not alter `x`.
 *
 * @return {*} A clone of `x`, i.e., the return value and `x` should not compare equal.
 * If `deepCopy=true`, all internal components are also cloned.
 */
export function CLONE(x, { deepCopy = true } = {}) {
    if (x instanceof Object) {
        let options = { deepCopy };
        if ("_bioconductor_CLONE" in x) {
            let output = Object.create(x.constructor.prototype); // avoid validity checks.
            x._bioconductor_CLONE(output, options);
            return output;
        }

        if (utils.isArrayLike(x)) {
            if (x.constructor == Array) {
                return x.map(y => CLONE(y, options));
            } else if (deepCopy) {
                return x.slice();
            } else {
                return x.subarray();
            }
        }

        if (x.constructor == Object) {
            if (deepCopy) {
                let output = {};
                for (const [k, v] of Object.entries(x)) {
                    output[k] = CLONE(v);
                }
                return output;
            } else {
                return { ...x };
            }
        }
    }

    // Immutable atomics should be all that's left.
    return x;
}

/**
 * Split a vector-like object along its length according to the levels of a factor of the same length.
 * This works automatically for all classes for which there is a {@linkcode SLICE} method,
 * but custom classes may also choose to define their own `_bioconductor_SPLIT` method. 
 *
 * @param {*} x - Some vector-like object.
 * @param {Array|TypedArray} factor - Array containing the factor to use for splitting.
 * This should have the same length as `x`.
 *
 * Alternatively, the output of {@linkcode presplitFactor} can be supplied.
 *
 * @return {Object} An object containing one key per level of `factor`,
 * where the value is the slice of `x` corresponding to the indices of that level in `factor`.
 */
export function SPLIT(x, factor) {
    if (factor.constructor != Object) {
        factor = misc.presplitFactor(factor);
    }

    if ("_bioconductor_SPLIT" in x) {
        return x._bioconductor_SPLIT(factor);
    }

    let output = {};
    for (const [k, v] of Object.entries(factor)) {
        output[k] = SLICE(x, v);
    }

    return output;
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Wed Jan 18 2023 07:00:36 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
